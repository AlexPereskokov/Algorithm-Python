# Берём уже решённую нами задачу, а именно ДЗ 2.3(имеет функции, достаточно проста)

# Условие задачи следующее:
# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, то надо вывести число 6843.

# Задача была решена с помощью ide PyCharm 2020.2
# Python Interpreter 3.8

# Поскольку мы не приследуем цели получения ответа в рамках задчи ДЗ 2.3, изменим return на массив переменных.
# Это позволит нам сразу получить return, который мы и хотим анализировать.
import sys
import random


# 1 вариант.
def revers_1(num):
    rev_num = 0
    _part_num = 0
    _cf = 0.1
    for i in num:
        _cf *= 10
        _part_num = int(i) * _cf
        rev_num += _part_num
    lst = [num, int(rev_num), _cf, _part_num]
    return lst


# 2 вариант.
def revers_2(num):
    rev_num = ''.join(reversed(num))
    lst = [num, int(rev_num)]
    return lst


# 3 вариант.
def revers_3(num):
    rev_num = num[::-1]
    lst = [num, int(rev_num)]
    return lst


number = str(random.randint(10000000, 1000000000))
obj_1 = revers_1(number)
obj_2 = revers_2(number)
obj_3 = revers_3(number)


# Аддаптируем наш подсчёт и прогоняем функцию подсчёта памяти по трём нашим случаям
# Убрал проверку на словарь, только листы у нас
# Добавил условие проверки цикла на строку, ибо тогда происходит зацикливание
# Добавил подсчёт суммы, как только всё завершится в рекурсивном порядке
def show(obj):
    _sum_size = 0
    print(f' {type(obj)=}, {sys.getsizeof(obj)=}, {obj=})')
    if hasattr(obj, '__iter__'):
        for item in obj:
            if type(obj) == str:
                break
            else:
                show(item)
            _sum_size += sys.getsizeof(item)
    if _sum_size != 0:
        print(f' Конечная сумма равна {_sum_size} \n')


# Смотрим запуски наших собранных листов
show(obj_1)
show(obj_2)
show(obj_3)

# Вывод:
# Как и по времени исполнения, так и по затратам памяти 1 вариант тяжелее (134)
# 2 и 3 вариант показали равные результаты, так как и тип и заполненность переменных равна (86)
# 1 вариант кода тяжелее, поскольку используются дополнительные побочные переменные
# По сумме двух задач, вариант 3 остался предпочтительным
